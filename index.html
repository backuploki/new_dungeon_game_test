<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>The Hidden Staircase</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: sans-serif; touch-action: none; }
        
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; 
            display: flex; flex-direction: column; justify-content: center; align-items: center;
        }
        
        #instructions {
            color: rgba(255,255,255,0.9); 
            background: rgba(0,0,0,0.6); 
            padding: 20px; border-radius: 10px;
            text-align: center;
            pointer-events: auto;
            border: 1px solid #444;
        }

        .thumb-zone {
            position: absolute; bottom: 40px; width: 140px; height: 140px;
            border: 2px solid rgba(255,255,255,0.1);
            background: rgba(255,255,255,0.05);
            border-radius: 50%;
            pointer-events: none;
        }
        
        .stick-nub {
            position: absolute; top: 50%; left: 50%; width: 50px; height: 50px;
            background: rgba(255, 200, 0, 0.3);
            border-radius: 50%;
            transform: translate(-50%, -50%);
        }

        #left-zone { left: 20px; }
        #right-zone { right: 20px; }
        .zone-label { position: absolute; bottom: -30px; width: 100%; text-align: center; color: #aaa; font-size: 12px; font-weight: bold; }
    </style>
</head>
<body>

<div id="ui-layer">
    <div id="instructions">
        <h2>THE HIDDEN STAIRS</h2>
        <p>The Watcher waits ahead.<br>Find the side passage.</p>
    </div>
    <div id="left-zone" class="thumb-zone"><div class="stick-nub" id="left-nub"></div><div class="zone-label">WALK</div></div>
    <div id="right-zone" class="thumb-zone"><div class="stick-nub" id="right-nub"></div><div class="zone-label">LOOK</div></div>
</div>

<script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
    }
  }
</script>

<script type="module">
    import * as THREE from 'three';

    // --- 1. SETUP ---
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x050505, 0.06);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.rotation.order = 'YXZ'; 

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true; 
    document.body.appendChild(renderer.domElement);

    // --- 2. INPUT & CONTROLS ---
    const input = { moveX: 0, moveY: 0, lookX: 0, lookY: 0 };
    const LOOK_SENSITIVITY = 0.004; 
    const WALK_SPEED = 7.0;

    const leftNub = document.getElementById('left-nub');
    const rightNub = document.getElementById('right-nub');
    const instructions = document.getElementById('instructions');
    const touches = {}; 
    
    document.addEventListener('touchstart', (e) => { e.preventDefault(); instructions.style.display = 'none'; handleTouch(e); });
    document.addEventListener('touchmove', (e) => { e.preventDefault(); handleTouch(e); });
    document.addEventListener('touchend', endTouch);
    
    const halfWidth = window.innerWidth / 2;

    function handleTouch(e) {
        for (let i = 0; i < e.touches.length; i++) {
            const t = e.touches[i];
            if (!touches[t.identifier]) touches[t.identifier] = { startX: t.clientX, startY: t.clientY };
            const startX = touches[t.identifier].startX;
            const deltaX = t.clientX - startX;
            const deltaY = t.clientY - touches[t.identifier].startY;

            if (startX < halfWidth) { // Move
                input.moveX = Math.max(-1, Math.min(1, deltaX / 60)); 
                input.moveY = Math.max(-1, Math.min(1, deltaY / 60));
                leftNub.style.transform = `translate(calc(-50% + ${Math.max(-60,Math.min(60,deltaX))}px), calc(-50% + ${Math.max(-60,Math.min(60,deltaY))}px))`;
            } else { // Look
                const prevX = touches[t.identifier].lastX || t.clientX;
                const prevY = touches[t.identifier].lastY || t.clientY;
                input.lookX = (t.clientX - prevX) * LOOK_SENSITIVITY; 
                input.lookY = (t.clientY - prevY) * LOOK_SENSITIVITY;
                touches[t.identifier].lastX = t.clientX;
                touches[t.identifier].lastY = t.clientY;
                rightNub.style.transform = `translate(calc(-50% + ${Math.max(-20,Math.min(20,deltaX))}px), calc(-50% + ${Math.max(-20,Math.min(20,deltaY))}px))`;
            }
        }
    }
    function endTouch(e) {
        let leftActive = false;
        const activeIds = Array.from(e.touches).map(t => t.identifier);
        for (let id in touches) {
            if (!activeIds.includes(parseInt(id))) {
                if (touches[id].startX < halfWidth) { input.moveX = 0; input.moveY = 0; leftNub.style.transform = `translate(-50%, -50%)`; }
                delete touches[id];
            }
        }
    }

    // --- 3. LEVEL CONSTRUCTION ---
    const textureLoader = new THREE.TextureLoader();
    function createTexture(color, noise) {
        const canvas = document.createElement('canvas'); canvas.width=64; canvas.height=64;
        const ctx = canvas.getContext('2d'); 
        ctx.fillStyle = color; ctx.fillRect(0,0,64,64);
        if(noise) { for(let i=0;i<200;i++){ ctx.fillStyle=`rgba(0,0,0,${Math.random()*0.2})`; ctx.fillRect(Math.random()*64,Math.random()*64,2,2); } }
        return new THREE.CanvasTexture(canvas);
    }

    // Materials
    const matWall = new THREE.MeshStandardMaterial({ map: createTexture('#555555', true), roughness: 0.7 });
    const matFloor = new THREE.MeshStandardMaterial({ map: createTexture('#222222', true), roughness: 0.8 });
    const matRedWall = new THREE.MeshStandardMaterial({ map: createTexture('#880000', true), roughness: 0.5 });
    const matRedFloor = new THREE.MeshStandardMaterial({ map: createTexture('#440000', true), roughness: 0.6 });
    const matDoor = new THREE.MeshStandardMaterial({ color: 0x8899aa, roughness: 0.2, metalness: 0.9 }); // Metallic Blue-Grey

    const TILE_SIZE = 5;
    const lights = [];

    // Helper: Build a room/hallway segment
    function buildBlock(x, y, z, w, h, d, mat) {
        const mesh = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), mat);
        mesh.position.set(x, y, z);
        mesh.castShadow = true; mesh.receiveShadow = true;
        scene.add(mesh);
        return mesh;
    }

    // --- ZONE 1: MAIN HALL ---
    // Floor & Ceiling (Z 5 to -55)
    buildBlock(0, 0, -25, TILE_SIZE, 0.1, 60, matFloor); // Floor
    buildBlock(0, TILE_SIZE, -25, TILE_SIZE, 0.1, 60, matWall); // Ceiling

    // RIGHT WALL (Solid)
    buildBlock(2.5 + 0.5, TILE_SIZE/2, -25, 1, TILE_SIZE, 60, matWall);

    // LEFT WALL (With a hole!)
    // Segment 1: Start to Junction (Z 5 to -22.5)
    buildBlock(-3, TILE_SIZE/2, -8.75, 1, TILE_SIZE, 27.5, matWall);
    // Segment 2: Junction GAP (Z -22.5 to -27.5 is EMPTY)
    // Segment 3: Junction to End (Z -27.5 to -55)
    buildBlock(-3, TILE_SIZE/2, -41.25, 1, TILE_SIZE, 27.5, matWall);

    // END WALL (Behind Ghost)
    buildBlock(0, TILE_SIZE/2, -55.5, TILE_SIZE, TILE_SIZE, 1, matWall);

    // Lights
    addLight(0, 3, -10, 0xffaa00, 10);
    addLight(0, 3, -40, 0xffaa00, 5); // Dimmer near ghost

    // --- ZONE 2: SIDE PASSAGE ---
    // Goes Left from X -2.5 to -35. Z is centered at -25.
    buildBlock(-20, 0, -25, 40, 0.1, TILE_SIZE, matFloor); // Floor
    buildBlock(-20, TILE_SIZE, -25, 40, 0.1, TILE_SIZE, matWall); // Ceiling
    
    // Side Walls
    buildBlock(-20, TILE_SIZE/2, -22.5-0.5, 40, TILE_SIZE, 1, matWall); // North wall of side hall
    buildBlock(-20, TILE_SIZE/2, -27.5+0.5, 40, TILE_SIZE, 1, matWall); // South wall of side hall

    // Light at Junction to show the turn
    addLight(-5, 3, -25, 0xffaa00, 8);

    // --- ZONE 3: THE DOOR ---
    // Located at X = -38
    const doorMesh = buildBlock(-38, TILE_SIZE/2, -25, 0.5, TILE_SIZE-0.5, TILE_SIZE-0.5, matDoor);
    
    // SPOTLIGHT on the door so you see it
    const doorSpot = new THREE.SpotLight(0xffffff, 50);
    doorSpot.position.set(-30, 4, -25);
    doorSpot.target = doorMesh;
    doorSpot.angle = 0.5;
    scene.add(doorSpot);
    scene.add(doorSpot.target);

    // --- ZONE 4: STAIRS ---
    // X -40 to -60. Y drops.
    for(let i=0; i<10; i++) {
        const sx = -42 - (i * 2); // Moving left
        const sy = -1 - i;        // Moving down
        buildBlock(sx, sy, -25, 2, 1, TILE_SIZE, matRedFloor); // Step
        buildBlock(sx, sy + TILE_SIZE + 3, -25, 2, 1, TILE_SIZE, matRedWall); // Slanted Ceiling
    }
    // Light above stairs
    addLight(-50, 2, -25, 0xff0000, 5);

    // --- ZONE 5: RED HELL ---
    // Starts X -62
    buildBlock(-85, -10, -25, 40, 0.1, TILE_SIZE, matRedFloor); // Floor
    buildBlock(-85, -10 + TILE_SIZE, -25, 40, 0.1, TILE_SIZE, matRedWall); // Ceiling
    
    // Walls
    buildBlock(-85, -10 + TILE_SIZE/2, -28, 40, TILE_SIZE, 1, matRedWall);
    buildBlock(-85, -10 + TILE_SIZE/2, -22, 40, TILE_SIZE, 1, matRedWall);

    // Purple Lights
    addLight(-70, -7, -25, 0xff00ff, 15);
    addLight(-95, -7, -25, 0xff00ff, 15);


    // --- THE WATCHER (GHOST) ---
    const ghostGroup = new THREE.Group();
    const ghostGeo = new THREE.CapsuleGeometry(0.7, 2, 4, 8);
    const ghostMat = new THREE.MeshBasicMaterial({ color: 0x000000 }); 
    const ghostBody = new THREE.Mesh(ghostGeo, ghostMat);
    ghostBody.position.y = 1.5;
    ghostGroup.add(ghostBody);

    const eyeGeo = new THREE.SphereGeometry(0.15, 16, 16);
    const eyeMat = new THREE.MeshBasicMaterial({ color: 0xff0000 });
    const eyeL = new THREE.Mesh(eyeGeo, eyeMat); eyeL.position.set(-0.25, 2.2, 0.6); ghostGroup.add(eyeL);
    const eyeR = new THREE.Mesh(eyeGeo, eyeMat); eyeR.position.set(0.25, 2.2, 0.6); ghostGroup.add(eyeR);
    
    // Ghost Position (End of Main Hall)
    ghostGroup.position.set(0, 0.5, -50);
    scene.add(ghostGroup);


    function addLight(x, y, z, col, intens) {
        const light = new THREE.PointLight(col, intens, 15);
        light.position.set(x, y, z);
        light.castShadow = true;
        scene.add(light);
        const sphere = new THREE.Mesh(new THREE.SphereGeometry(0.1), new THREE.MeshBasicMaterial({color:col}));
        sphere.position.copy(light.position);
        scene.add(sphere);
        light.userData = { offset: Math.random()*100 };
        lights.push(light);
    }

    // --- 4. LOGIC & PHYSICS ---
    camera.position.set(0, 2, 0);

    // Walkable Zones [minX, maxX, minZ, maxZ, floorHeight]
    const zones = [
        [-2.5, 2.5, -53, 5, 0],       // Main Hall
        [-40, 2.5, -27.5, -22.5, 0],  // Side Hall
        [-62, -40, -27.5, -22.5, 'stair'], // Stairs
        [-105, -62, -27.5, -22.5, -10] // Red Room
    ];

    let doorOpen = false;

    // GAME LOOP
    const clock = new THREE.Clock();
    
    function animate() {
        requestAnimationFrame(animate);
        const delta = clock.getDelta();
        const time = clock.getElapsedTime();

        // Flicker lights
        lights.forEach(l => l.intensity = l.intensity * 0.95 + (Math.random() * l.intensity * 0.1)); // Subtle flicker

        // Ghost Animation
        ghostGroup.position.y = 0.5 + Math.sin(time * 2) * 0.2; 
        ghostGroup.lookAt(camera.position.x, 1.5, camera.position.z);

        // DOOR LOGIC
        const distToDoor = Math.abs(camera.position.x - (-38)) + Math.abs(camera.position.z - (-25));
        if (distToDoor < 10) doorOpen = true; // Increased range

        if (doorOpen && doorMesh.position.y < 8) {
            doorMesh.position.y += delta * 4; // Open faster
        }

        // LOOK
        camera.rotation.y -= input.lookX;
        camera.rotation.x -= input.lookY;
        camera.rotation.x = Math.max(-1.5, Math.min(1.5, camera.rotation.x));
        input.lookX = 0; input.lookY = 0;

        // MOVE
        if (Math.abs(input.moveY) > 0.05 || Math.abs(input.moveX) > 0.05) {
            const fwd = new THREE.Vector3(); camera.getWorldDirection(fwd); fwd.y=0; fwd.normalize();
            const right = new THREE.Vector3(); right.crossVectors(fwd, camera.up).normalize();

            const moveVec = new THREE.Vector3().addScaledVector(fwd, -input.moveY*WALK_SPEED*delta).addScaledVector(right, input.moveX*WALK_SPEED*delta);
            const nextX = camera.position.x + moveVec.x;
            const nextZ = camera.position.z + moveVec.z;

            // COLLISION
            let valid = false;
            let targetY = camera.position.y;

            for(let z of zones) {
                if (nextX >= z[0] && nextX <= z[1] && nextZ >= z[2] && nextZ <= z[3]) {
                    // Door Check: If door closed and trying to pass X = -38
                    if (z[4] === 0 && nextX < -37 && !doorOpen) continue; 

                    valid = true;
                    if (z[4] === 'stair') {
                        const pct = (nextX - (-40)) / (-62 - (-40)); 
                        targetY = 2 + (pct * -10); 
                    } else {
                        targetY = 2 + z[4];
                    }
                    break;
                }
            }

            if (valid) {
                camera.position.x = nextX;
                camera.position.z = nextZ;
                camera.position.y += (targetY - camera.position.y) * 0.15;
            }
        }
        renderer.render(scene, camera);
    }

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    animate();
</script>
</body>
</html>
